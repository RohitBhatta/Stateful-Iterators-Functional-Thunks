Due date: Sunday 3/6/2016 @ 11:59pm

- Please remember to answer the questions in REPORT.txt

- This assignment involves implementing a couple of exotic
  abstractions. It involves writing a small amount of
  mind-bending code. Please try to enjoy the experience

Assignment:
~~~~~~~~~~~

(1) Answer the questions in REPORT.txt

(2) Add two new abstractions to C:
     - Stateful iterators
     - Function thunks

Stateful iterators
~~~~~~~~~~~~~~~~~~~

Let's start with an example:

#include <iterator.h>

/* An iterator that generates 10, 20, 30, 40, 0, 0, 0, ..... */
long func(void) {
    long x = 10;
    yield(x);
    x += 10;
    yield(x);
    x += 10;
    yield(x);
    x += 10;
    yield(x);
    return 0;
}

int main() {
    Iterator* iter = newIterator(func);    /* create an instance of the iterator */
    next(iter);     // get the next value, 10
    next(iter);     // get the next value, 20
    next(iter);     // get the next value, 30
    next(iter);     // get the next value, 40
    next(iter);     // get the next value, 0
    ...
}

func is a generator function. In addition to being a normal C function, func
can do two things:

    - call yield, producing a new value
    - return, producing an infinite stream of the returned value

A generator function can be wrapped in an iterator using newIterator

    Iterator* iter = newIterator(gen);

A consumer can get the next value produced by an iterator by calling next(iter)

Execution of the iterator is lazy; it executes the minimal amount of code needed
in order to produce the next value

Notice how our mechanisms create some unusual control flows:

    - Calling next suspends the execution of main and starts the execution
      of func

    - Calling yield suspends the execution of func and resumes the execution
      of main

Function thunks
~~~~~~~~~~~~~~~

What if someone wants to use a generator that takes arguments:

/* generate an infinite stream of x */
long gen(long x) {
    while (1) yield(x);
    return 0;
}

We can't pass "gen" to "newIterator" because it expects a function with
no arguments.

We can remedy the situation by introducing thunks; dynamically generated
functions:

F0 f = thunk1(gen,5)

returns a pointer to a function "f". When "f" is called, it calls "gen"
passing it 5 as an argument.

    f();     // same as calling gen(5)

Now, we can create our iterator:

Iterator* iter = newIterator(f)

Limitations:
~~~~~~~~~~~~

- Thunks can only handle long arguments

- An iterator can't depend on itself (directly or indirectly).

For example:

    Iterator* it;

    long func(void) {
        next(it);
    }

    int main() {
        it = newIterator(func);
        next(it);
    }

func will ask itself for a value that it can never produce.

More generally if a calles next(b) and b calls next(c) and c calls next(a)
when we have what's called a deadlock state and we can't make forward progress

Your code is supposed to detect such state and call the "deadlock" function when
it happens

Code structure:
~~~~~~~~~~~~~~~

- The iterator and thunk implementation and all their supporting code
  is in the src directory. The Makefile will pick up any .c or .S files
  in the src directory

Files
~~~~~

src/*.[Sch]     iterator/thunk implementation

For each test "tx"

tx.c      the source program
tx        the compiled program (generated by the Makefile)
tx.out    output produced by running tx
tx.ok     the expected output
tx.diff   the difference between tx.out tx.ok

Make targets:
~~~~~~~~~~~~~

make           # compile and link all tests
make tx        # compile and link the given test
make tx.out    # run the given test and produce its output
make tx.diff   # produce the difference between tx.out and tx.ok
make tx.result # produce a summary of the result of running tx

make outs      # produce all the out files
make diffs     # produce all the diff files
make test      # produce summary output for all tests

Files to leave alone
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   t?.c
   t?.ok

You can also add your own tests by creating a pair of
files (for example mytest.fun and mytest.ok)

To debug
~~~~~~~~

GDB could get confused by the unusual control flow.

    $ make t0
    $ gdb ./t0
    gdb) run


